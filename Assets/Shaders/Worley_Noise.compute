#pragma kernel CSWorley2D
#pragma kernel CSWorley3D

#pragma multi_compile _ _Invert

int _Resolution;
int _CellResolution;
StructuredBuffer<float2> _FeaturePoints2D;
StructuredBuffer<float3> _FeaturePoints3D;
RWTexture2D<float4> _NoiseTex2D;
RWTexture3D<float> _NoiseTex3D;

float2 noise2x2 (float2 p)
{
    float x = dot(p, float2(123.4, 234.5));
    float y = dot(p, float2(345.6, 456.7));
    float2 noise = float2(x, y);
    noise = sin(noise);
    noise = noise * 43758.5453;
    noise = frac(noise);

    return noise;
}

float worley2D (StructuredBuffer<float2> points, int texResolution, int numCellPerAxis, float2 pixelIndex)
{
    float2 uv = pixelIndex / texResolution;
    uv *= numCellPerAxis;
    float2 currentCellId = floor(uv);
    float2 currentCellCoord = frac(uv);
    currentCellCoord -= 0.5;

    float minDistFromPixel =  1000000.0;
    for (float i = -1.0; i <= 1.0; ++i)
    {
        for (float j = -1.0; j <= 1.0; ++j)
        {
            float2 adjCellCoords = float2(i, j);
            //float2 noise = noise2x2(currentCellId + adjCellCoords);
            if (currentCellId.x + i < 0 || currentCellId.x + i >= numCellPerAxis || currentCellId.y + j < 0 || currentCellId.y + j >= numCellPerAxis)
                continue;
            float2 noise = points[(int)currentCellId.x + i + ((int)currentCellId.y + j)* numCellPerAxis];
            float2 pointOnAdjCell = adjCellCoords + noise;

            float dist = distance(currentCellCoord, pointOnAdjCell);
            minDistFromPixel = min(dist, minDistFromPixel);
        }
    }

    #ifdef _Invert
        float color = 1.0 - minDistFromPixel;
    #else
        float color = minDistFromPixel;
    #endif
    
    return color;
}

float worley3D (StructuredBuffer<float3> points, int texResolution, int numCellPerAxis, float3 pixelIndex)
{
    float3 uvz = pixelIndex / texResolution;
    uvz *= numCellPerAxis;
    float3 currentCellId = floor(uvz);
    float3 currentCellCoord = frac(uvz);
    currentCellCoord -= 0.5;

    float minDistFromPixel =  1000000.0;
    for (float i = -1.0; i <= 1.0; ++i)
    {
        for (float j = -1.0; j <= 1.0; ++j)
        {
            for (float z = -1.0; z <= 1.0; ++z)
            {
                float3 adjCellCoords = float3(i, j, z);
                if (currentCellId.x + i < 0 || currentCellId.x + i >= numCellPerAxis ||
                    currentCellId.y + j < 0 || currentCellId.y + j >= numCellPerAxis ||
                    currentCellId.z + z < 0 || currentCellId.z + z >= numCellPerAxis)
                    continue;
                
                float3 noise = points[
                    (int)currentCellId.x + i +
                    ((int)currentCellId.y + j) * numCellPerAxis +
                    ((int)currentCellId.z + z) * numCellPerAxis * numCellPerAxis
                    ];
                float3 pointOnAdjCell = adjCellCoords + noise;

                float dist = distance(currentCellCoord, pointOnAdjCell);
                minDistFromPixel = min(dist, minDistFromPixel);
            }
        }
    }

    #ifdef _Invert
        float color = 1.0 - minDistFromPixel;
    #else
        float color = minDistFromPixel;
    #endif
    
    return color;
}

[numthreads(8,8,1)]
void CSWorley2D (uint3 id : SV_DispatchThreadID)
{
    float color = worley2D(_FeaturePoints2D, _Resolution, _CellResolution, id.xy);
    _NoiseTex2D[id.xy] = float4(color, color, color, 1.0);
}

[numthreads(8,8,8)]
void CSWorley3D (uint3 id : SV_DispatchThreadID)
{
    _NoiseTex3D[id.xyz] = worley3D(_FeaturePoints3D, _Resolution, _CellResolution, id.xyz);
}